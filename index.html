<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>DivANS</title>
<script type="text/javascript" src="brotli_wrapper.js"></script>
<script type="text/javascript">
    const memory = new WebAssembly.Memory({ initial: 256, maximum: 256 });
    const importObj = {
      env: {
          log2f: Math.log2,
          log2: Math.log2,
          exp2f: function(a) {return Math.exp(2, a);},
          exp2: function(a) {return Math.exp(2, a);},
          abortStackOverflow: () => { throw new Error('overflow'); },
          table: new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }),
          tableBase: 0,
          memory: memory,
          memoryBase: 1024,
          STACKTOP: 0,
          STACK_MAX: memory.buffer.byteLength
      }
   };
   var helper = [0x49, 0x74, 0x20, 0x73, 0x6e, 0x6f, 0x77, 0x65, 0x64, 0x2c, 0x20, 0x72,
           0x61, 0x69, 0x6e, 0x65, 0x64, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x68,
           0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61,
           0x6d, 0x65, 0x20, 0x6d, 0x6f, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x2e, 0x0a];
   var file = new Uint8Array(10000);
   var count = 0;
   for (var i= 0; i + 3 < file.length; i+= 4) {
      file[i] = i & 0xff;
      file[i + 1] = (i >> 8) & 0xff;
      file[i + 2] = (i >> 16) & 0xff;
      file[i + 3] = (i >> 24) & 0xff;
   }
   for (var i = 0; i < helper.length; i+= 1) {
      file[i] = helper[i];
   }
         // example divans file
   var _example_dv_file = [0xff, 0xe5, 0x8c, 0x9f, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0xd5, 0xbe, 0x98, 0x84, 0x91,
             0x0a, 0x00, 0x00, 0x22, 0x12, 0x07, 0xb2, 0xf6, 0x07, 0x08, 0x00, 0x65,
             0xf6, 0xb6, 0x4b, 0xe8, 0xc2, 0x3c, 0x14, 0x6b, 0x29, 0xa8, 0xf4, 0xf5,
             0x27, 0x17, 0x6c, 0x11, 0x07, 0x59, 0xf3, 0x95, 0x82, 0xe4, 0x97, 0xd3,
             0x1e, 0xcb, 0x7c, 0x01, 0x23, 0x00, 0x83, 0x21, 0x18, 0x61, 0xf2, 0x63,
             0x30, 0x1e, 0x31, 0x4a, 0x54, 0x0d, 0x20, 0x0b, 0x00, 0x00, 0x9a, 0xf4,
             0xeb, 0xe1, 0xe5, 0x35, 0x2f, 0xaf, 0xc7, 0x09, 0x92, 0xe9, 0x1d, 0xab,
             0xbd, 0xd9, 0x43, 0x4f, 0xb7, 0x08, 0xff, 0xfe, 0xff, 0xfe, 0xfb, 0x53,
             0x04, 0x61, 0x6e, 0x73, 0x7e];
   function array_buffers_length(arr) {
             var total_length = 0;
             for (var i = 0; i < arr.length; i++) {
                total_length += arr[i].length;
             }
             return total_length;
   }
   function array_buffers_join(arr) {
             var total_length = array_buffers_length(arr);
             var ret = new Uint8Array(total_length);
             total_length = 0;
             for (var i = 0; i < arr.length; i++) {
                ret.set(arr[i], total_length);
                total_length += arr[i].length;
             }
             return ret;
   }
   var el = document.createElement('a');
   var pre = document.createElement('pre');
   var input_dialog = document.createElement("input");
   var brotliComparisonText = document.createElement('div');
   function init() {
         var ascii_string = "";
         for (var i =0;i < helper.length; i += 1) {
             ascii_string += String.fromCharCode(file[i]);
         }
         ascii_string += "\nFollowed by 32 bit byte offsets from 48 to 10000\n";
         document.body.appendChild(document.createTextNode("Example file:"));
         pre.style.backgroundColor = "#EBECE4";
         pre.appendChild(document.createTextNode(ascii_string));
         document.body.appendChild(pre);
         input_dialog.type = "file";
         input_dialog.id = "files";
         input_dialog.name="files[]";
         input_dialog.multiple="";
         document.body.appendChild(input_dialog);
         document.body.appendChild(document.createElement('br'));
         document.body.appendChild(document.createTextNode("(Drag and drop your file in the gray area to compress)"));
         document.body.appendChild(document.createElement("br"));
         document.body.appendChild(el);
         document.body.appendChild(document.createElement('br'));
         brotliComparisonText.appendChild(document.createTextNode(""));
         document.body.appendChild(brotliComparisonText)
         document.body.appendChild(document.createElement("br"));
         var floatDiv = document.createElement("div");
         floatDiv.style.float = "left";
         floatDiv.style.textAlign = "center";
         document.body.appendChild(floatDiv);
         window.brotliSize = document.createElement("div");
         floatDiv.appendChild(window.brotliSize);
         window.brotliIR = document.createElement("textarea");
         window.brotliIR.onclick = function() {this.select();};
         window.brotliIR.rows = "20";
         window.brotliIR.cols = "80";
         window.brotliIR.wrap = "off"
         floatDiv.appendChild(window.brotliIR);
         window.brotliIR.style.visibility = "hidden";
   }
   document.addEventListener("DOMContentLoaded", init);
   var wasm_callback = obj => {
         var should_debug = false;
         if (should_debug) {
             console.log("Imports", WebAssembly.Module.imports(obj.module));
             console.log("Exports", obj.instance.exports);
         }
         function encodeBrotliAndShowResult(file_array_buffer, file_orig_length) {
             Brotli.runBrotliDestroysInput(file_array_buffer,
                 function(original_input, output_len, brotli_ir) {
                     window.brotliIR.value = brotli_ir;
                     window.brotliIR.style.visibility = "visible";
                     window.brotliSize.innerHTML = ""; // clear
                     brotliComparisonText.removeChild(brotliComparisonText.firstChild);
                     brotliComparisonText.appendChild(document.createTextNode("[Brotli compressed " + output_len + "/" + file_orig_length + " bytes]"))
                     window.brotliSize.appendChild(document.createTextNode(
                         "IR below"));
                 });
         }
         function encode(external_uint8_buffer, debug) {
             var list_of_encoded_buffers = [];
             var divans = obj.instance.exports;
             var state = divans.divans_new_compressor();
             var input_ptr = divans.divans_compressor_malloc_u8(state, external_uint8_buffer.length);
             var output_ptr = divans.divans_compressor_malloc_u8(state, 4096);
             var input_offset_ptr = divans.divans_compressor_malloc_usize(state, 1);
             var output_offset_ptr = divans.divans_compressor_malloc_usize(state, 1);
             var input_buf = new Uint8Array(divans.memory.buffer, input_ptr, external_uint8_buffer.length);
             var output_buf = new Uint8Array(divans.memory.buffer, output_ptr, 4096);
             var input_offset_buf = new Uint32Array(divans.memory.buffer, input_offset_ptr, 1);
             input_buf.set(external_uint8_buffer)
             var output_size = 0;
             var ret = 0;
             do {
                ret = divans.divans_encode(state, input_ptr, external_uint8_buffer.length, input_offset_ptr,
                               output_ptr, 4096, output_offset_ptr);
                var output_offset_buf = new Uint32Array(divans.memory.buffer,output_offset_ptr, 1);
                output_size += output_offset_buf[0];
                if (debug) {
                    console.log(ret);
                }
                var output_offset_buf = new Uint32Array(divans.memory.buffer,output_offset_ptr, 1);
                if (output_offset_buf[0] !== 0) {
                     if (debug) {
                          console.log(output_offset_buf[0]);
                     }
                     var produced_data = new Uint8Array(divans.memory.buffer, output_ptr, output_offset_buf[0]);
                     if (debug) {
                          console.log(produced_data);
                     }
                     list_of_encoded_buffers[list_of_encoded_buffers.length] = new Uint8Array(produced_data);
                }
                output_offset_buf[0] = 0;
             } while(ret != 0 && ret != 1);
             do {
                ret = divans.divans_encode_flush(state,
                               output_ptr, 4096, output_offset_ptr);
                var output_offset_buf = new Uint32Array(divans.memory.buffer,output_offset_ptr, 1);
                output_size += output_offset_buf[0];
                if (output_offset_buf[0] != 0) {
                     var produced_data = new Uint8Array(divans.memory.buffer, output_ptr, output_offset_buf[0]);
                     if (debug) {
                         console.log(produced_data);
                     }
                     list_of_encoded_buffers[list_of_encoded_buffers.length] = new Uint8Array(produced_data);
                }
                output_offset_buf[0] = 0;
             } while(ret != 0);
             if (debug) {
                 console.log("TOTAL SIZE " + output_size);
             }
             divans.divans_compressor_free_u8(state, input_ptr, external_uint8_buffer.length);
             divans.divans_compressor_free_u8(state, output_ptr, 4096);
             divans.divans_compressor_free_usize(state, input_offset_ptr, 1);
             divans.divans_compressor_free_usize(state, output_offset_ptr, 1);
             divans.divans_free_compressor(state);
             return list_of_encoded_buffers;
         }
         function decode(external_uint8_buffer, debug) {
             var list_of_decoded_buffers = [];
             var divans = obj.instance.exports;
             var state = divans.divans_new_serial_decompressor();
             var input_ptr = divans.divans_decompressor_malloc_u8(state, external_uint8_buffer.length);
             var output_ptr = divans.divans_decompressor_malloc_u8(state, 4096);
             var input_offset_ptr = divans.divans_decompressor_malloc_usize(state, 1);
             var output_offset_ptr = divans.divans_decompressor_malloc_usize(state, 1);
             var input_buf = new Uint8Array(divans.memory.buffer, input_ptr, external_uint8_buffer.length);
             var output_buf = new Uint8Array(divans.memory.buffer, output_ptr, 4096);
             var input_offset_buf = new Uint32Array(divans.memory.buffer, input_offset_ptr, 1);
             input_buf.set(external_uint8_buffer)
             var output_size = 0;
             var ret = 0;
             do {
                ret = divans.divans_decode(state, input_ptr, external_uint8_buffer.length, input_offset_ptr,
                               output_ptr, 4096, output_offset_ptr);
                var output_offset_buf = new Uint32Array(divans.memory.buffer,output_offset_ptr, 1);
                output_size += output_offset_buf[0];
                if (debug) {
                     console.log(ret);
                }
                var output_offset_buf = new Uint32Array(divans.memory.buffer,output_offset_ptr, 1);
                if (output_offset_buf[0] !== 0) {
                     if (debug) {
                         console.log(output_offset_buf[0]);
                     }
                     var produced_data = new Uint8Array(divans.memory.buffer, output_ptr, output_offset_buf[0]);
                     if (debug) {
                         console.log(produced_data);
                     }
                     list_of_decoded_buffers[list_of_decoded_buffers.length] = new Uint8Array(produced_data);
                }
                output_offset_buf[0] = 0;
             } while(ret != 0 && ret != 1 && ret != 3);
             if (debug) {
                 console.log("TOTAL SIZE " + output_size);
             }
             divans.divans_decompressor_free_u8(state, input_ptr, external_uint8_buffer.length);
             divans.divans_decompressor_free_u8(state, output_ptr, 4096);
             divans.divans_decompressor_free_usize(state, input_offset_ptr, 1);
             divans.divans_decompressor_free_usize(state, output_offset_ptr, 1);
             divans.divans_free_decompressor(state);
             if (ret != 0) {
                 return [];
             }
             return list_of_decoded_buffers;
         }
         function is_divans(file) {
             return file.length > 16 && file[0] == 255 && file[1] == 229 && file[2] == 140 && file[3] == 159;
         }
         var file_buf = new ArrayBuffer(file.length);
         new Uint8Array(file_buf).set(new Uint8Array(file));
         if (!is_divans(file)) {
             var div_file = encode(file, should_debug);
             encodeBrotliAndShowResult(file_buf, file.length);
             var dv_len = array_buffers_length(div_file);
             if (should_debug) {
                 var to_decode = array_buffers_join(div_file);
                 var rt = decode(to_decode, should_debug);
                 var rt_joined = array_buffers_join(rt);
                 console.log(rt_joined.length, file.length);
                 var ok = (rt_joined.length == file.length);
                 for (var i = 0; i < rt_joined.length && i < file.length; i++) {
                   if (file[i] != rt_joined[i]) {
                      ok = false;
                   }
                 }
                 console.log("RT status", ok);
             }
             var blob = new Blob(div_file, {type:"application/binary+div"});
             var blobUrl = URL.createObjectURL(blob);
             el.appendChild(document.createTextNode("Download Divans File (" + dv_len+"/"+ file.length + "bytes)"));
             el.href = blobUrl;
         } else {
             var original_file = decode(file, should_debug);
             if (original_file.length == 0) {
                 el = document.createTextNode("Divans file incompatible with this decompressor");
                 
             } else {
                 var original_len = array_buffers_length(original_file);
                 var blob = new Blob(original_file, {type:"application/binary+div"});
                 var blobUrl = URL.createObjectURL(blob);
                 el.appendChild(document.createTextNode("Download Decompressed File (" + original_len+"/"+ file.length + "bytes)"));
                 el.href = blobUrl;
             }
         }
         function handleDragOver(event) {
             event.stopPropagation();
             event.preventDefault();
             event.dataTransfer.dropEffect = 'copy';
         }
         function handleDrop(event) {
             event.stopPropagation();
             event.preventDefault();
             var files = input_dialog.files;
             if (event && event.dataTransfer) {
                files = event.dataTransfer.files;
             }
             for (var i =0; files && i < files.length; i+= 1) {
                 var fileReader = new FileReader();
                 fileReader.onload = function(event) {
                     var file_array_buffer = event.target.result;
                     var file_contents = new Uint8Array(file_array_buffer);
                     if (is_divans(file_contents)) {
                         brotliComparisonText.removeChild(brotliComparisonText.firstChild);
                         brotliComparisonText.appendChild(document.createTextNode(""))
                         pre.removeChild(pre.firstChild); // no more text
                         pre.appendChild(document.createTextNode("Your Custom file, length " + file_contents.length + " is being decompressed"));
                         var original_file = decode(file_contents, should_debug);
                         if (original_file.length == 0) {
                             el = document.createTextNode("Divans file incompatible with this decompressor");
                         } else {
                             var original_len = array_buffers_length(original_file);
                             var blob = new Blob(original_file, {type:"application/binary+div"});
                             var blobUrl = URL.createObjectURL(blob);
                             el.appendChild(document.createTextNode("Download Decompressed File (" + original_len+"/"+ file_contents.length + " bytes)"));
                             el.href = blobUrl;
                         }
                     } else {
                         brotliComparisonText.removeChild(brotliComparisonText.firstChild);
                         brotliComparisonText.appendChild(document.createTextNode("[Brotli processing...]"))
                         pre.removeChild(pre.firstChild); // no more text
                         var file_orig_length = file_contents.length
                         pre.appendChild(document.createTextNode("Your Custom file, length " + file_orig_length + " is being compressed"));
                         var div_file = encode(file_contents, should_debug);
                         encodeBrotliAndShowResult(file_array_buffer, file_orig_length);
                         var dv_len = array_buffers_length(div_file);
                         var blob = new Blob(div_file, {type:"application/binary+div"});
                         var blobUrl = URL.createObjectURL(blob);
                         if (el.firstChild) {
                             el.removeChild(el.firstChild);
                         }
                         el.appendChild(document.createTextNode("Download Divans File (" + dv_len+"/"+ file_orig_length + " bytes)"));
                         el.href = blobUrl;
                     }
                 }
                 fileReader.readAsArrayBuffer(files[i]);
             }
         }
         
         input_dialog.addEventListener('change', handleDrop, false);
         if (input_dialog.files && input_dialog.files.length) {
             handleDrop();
         }
         pre.addEventListener("dragover", handleDragOver);
         pre.addEventListener("drop", handleDrop);
   };
   var wasm_divans_bytecode = 'divans.wasm';
   if (WebAssembly.instantiateStreaming) {
       WebAssembly.instantiateStreaming(fetch(wasm_divans_bytecode),
          importObj).then(wasm_callback)/*.catch((function(reason){
            console.error("wasm streaming compile failed: "+reason);
       }))*/;
    } else {
         var gmodule = null;
         fetch(wasm_divans_bytecode).then(response =>
         response.arrayBuffer()).then(bytes =>
             WebAssembly.compile(bytes)).then(function(module) {
                gmodule = module;
                return WebAssembly.instantiate(module, importObj);
             }).then(instance => wasm_callback({instance:instance, module:gmodule}));
    }
</script>
</head>
<body>
</body>
</html>
